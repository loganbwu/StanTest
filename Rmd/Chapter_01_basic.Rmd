_---
title: "PLAN for Chapter 1. Methodology for fitting ODE epidemic models"
subtitle: "This RMarkdown is a template as initially outlined in the progress report. Each task will be outlined and then followed by a code block to be completed."
output:
html_notebook:
number_sections: true
---


Do the basic comparison between seasonal and non-seasonal model fitting

```{r setup}
library(R.utils)
library(tidyverse)
library(rstan)
library(rstansim) # devtools::install_github("ewan-keith/rstansim")
library(parallel)
library(patchwork)
library(pbmcapply)
library(pbapply)
library(memoise)
library(RColorBrewer)
source("../R/constants.R")
source("../R/load_functions.R")

n_cores = parallelly::availableCores()
# n_cores = 6
options(mc.cores = n_cores)
message("Running on ", n_cores, " cores")
rstan_options(auto_write = TRUE)

n_iter = 500 # should be at least 500
n_chains = 1
n_repetitions = 3 # how many times to duplicate each scenario
cores_per_sampler = n_chains # 1 for mclapply, or n_chains if not running lots of scenarios
limit_runs = Inf # set to a finite number for testing, or Inf to run all
timelimit_per_run = 60*60 * 5
n_traces = 200 # limit for plotting sample trajectories
n_traces = min(n_traces, n_iter)
```

## Model implementation

Generate some data

```{r}
#initial conditions
I_init = 0.01
y0 = c(Il=0, I0=I_init, Sl=0, S0=1-I_init, CumulativeInfections=0)
n_years = 10

# constants for Stan
data_consts = list(y0 = y0,
                   t0 = -50*years,
                   N = 100000, # population size
                   r = 1./60, # r
                   gammal = 1./223, # gammal
                   f = 1./72, # f
                   alpha = 0.21, # alpha
                   beta = 0.66, # beta
                   rho = 0.21, # rho
                   delta = 0
)
```

Simulate some dummy data

```{r}
n_times = annual_subdivisions * n_years
data = data_init(data_consts,
                 ts = seq_len(n_times)*years/annual_subdivisions,
                 cases = rep(1, n_times),
                 n_times = n_times)
params = list(lambda=0.01, phi_inv=0.1, eps=0.001, kappa=1, phase=130)

sim = my_simulate_data_list(
  file = "../stan/champagne2022_seasonal_ext_2.stan",
  path = "sim_data",
  data_name = "seasonal",
  input_data = data,
  param_values = params,
  vars = c("ts", "incidence", "sim_cases")
)

synth_df = with(sim, tibble(
  ts = ts,
  incidence = incidence,
  cases = cases
))
```

Insert the new seasonal data into a data list and run the seasonal model on it.

```{r,}
# Edit data with generated values
data_sim = data_init(data_consts,
                     n_times = nrow(synth_df),
                     ts = synth_df$ts,
                     cases = synth_df$cases)

data_sim_agg = aggregate_data(data_sim)
synth_df_agg = with(data_sim_agg, tibble(ts = ts, cases = cases)) 

with(data_sim, tibble(ts = ts/years, cases = cases)) %>%
  ggplot(aes(x=ts, y=cases)) +
  geom_col() +
  scale_x_continuous(breaks = 0:100)
with(data_sim_agg, tibble(ts = ts/years, cases = cases)) %>%
  ggplot(aes(x=ts, y=cases)) +
  geom_col() +
  scale_x_continuous(breaks = 0:100)
```

```{r, eval=F}
fit_seasonal = sampling(stan_model("../stan/champagne2022_seasonal_ext_2.stan"),
                        data = data_sim,
                        iter = n_iter,
                        chains = n_chains)

fit_nonseasonal = sampling(stan_model("../stan/champagne2022_poisson.stan"),
                           data = data_sim_agg,
                           iter = n_iter,
                           chains = n_chains)
```

Manually inspect fits

```{r, eval=F}
post_seasonal = rstan::extract(fit_seasonal, c("lambda", "eps", "kappa", "phase")) %>%
  as_tibble() %>%
  pivot_longer(everything())

ggplot(post_seasonal, aes(x=value, color=name, fill=name)) +
  geom_density() +
  facet_wrap(vars(name), scales="free")

incidence_seasonal = extract_incidence(fit_seasonal, data_sim$ts)
ggplot(incidence_seasonal, aes(x=ts, y=incidence, group=trace)) +
  geom_line(alpha = 0.05) +
  geom_point(data = synth_df, aes(y=cases, group=NULL)) +
  coord_cartesian(ylim = c(0, NA))

post_nonseasonal = rstan::extract(fit_nonseasonal, c("lambda")) %>%
  as_tibble() %>%
  pivot_longer(everything())

ggplot(post_nonseasonal, aes(x=value, color=name, fill=name)) +
  geom_density() +
  facet_wrap(vars(name), scales="free")

incidence_nonseasonal = extract_incidence(fit_nonseasonal, data_sim_agg$ts)
ggplot(incidence_nonseasonal, aes(x=ts, y=incidence, group=trace)) +
  geom_line(alpha = 0.05) +
  geom_point(data = synth_df_agg, aes(y=cases, group=NULL)) +
  coord_cartesian(ylim = c(0, NA))
```

# Can we make a variety of scenarios?
Define a function to simulate cases for a scenario

```{r}
simulate_cases = function(data_consts, lambda, phi_inv, eps, kappa, phase) {
  n_times = annual_subdivisions * n_years
  data = data_init(data_consts,
                   cases = rep(1, n_times),
                   ts = seq_len(n_times) * years / annual_subdivisions,
                   n_times = n_times)
  params = list(lambda=lambda, phi_inv=phi_inv, eps=eps, kappa=kappa, phase=phase)
  synth_df = my_simulate_data(
    file = "../stan/champagne2022_seasonal_ext_2.stan",
    path = "sim_data",
    data_name = "seasonal",
    input_data = data,
    param_values = params,
    vars = c("ts", "incidence", "sim_cases")
  )
}
```

Create scenarios

```{r}
# Define the scenarios
range_lambda = seq(0.01, 0.012, length.out=3)
range_eps = seq(1e-12, 1-1e-12, length.out=3)
scenarios = expand_grid(
  lambda = range_lambda,
  phi_inv = 0.1,
  eps = range_eps,
  kappa = 1,
  phase = 130,
  rep = seq_len(n_repetitions)
) %>%
  mutate(ID = row_number(), .before=0)

# Simulate cases for each scenario
cases_scenarios = pbmclapply(seq_len(nrow(scenarios)), function(i) {
  lambda = scenarios$lambda[i]
  phi_inv = scenarios$phi_inv[i]
  eps = scenarios$eps[i]
  kappa = scenarios$kappa[i]
  phase = scenarios$phase[i]
  simulate_cases(data_consts, lambda, phi_inv, eps, kappa, phase)
})

# Attach simulation results to the scenarios dataframe
scenarios$ts = lapply(cases_scenarios, function(x) {x$ts})
scenarios$cases = lapply(cases_scenarios, function(x) {x$cases})

# Duplicate for each method
scenarios_long = scenarios %>%
  cross_join(tibble(method = c("../stan/champagne2022_seasonal_ext_2.stan",
                               "../stan/champagne2022_poisson.stan")))
# Replace data with aggregate data depending on the method
for (i in seq_len(nrow(scenarios_long))) {
  if (scenarios_long$method[i] == "../stan/champagne2022_poisson.stan") {
    scenarios_long$ts[[i]] = aggregate_time(scenarios_long$ts[[i]])
    scenarios_long$cases[[i]] = aggregate_cases(scenarios_long$cases[[i]])
  }
}
```

What do our synthetic data look like?

```{r}
scenarios %>%
  # distinct(scenario_ID, .keep_all=T) %>%
  unnest(cols = c("ts", "cases")) %>%
  ggplot(aes(x = ts/years, y = cases, group=interaction(lambda, eps, rep))) +
  geom_line(alpha = 0.6) +
  scale_color_gradient(trans = "log", breaks=10^seq(-5, 5)) +
  scale_x_continuous(breaks = 0:n_years) +
  scale_y_log10(labels = label_auto2) +
  facet_grid(rows = vars(lambda),
             cols = vars(eps),
             labeller = plot_labeller) +
  labs(x = "Year",
       y = "Monthly cases")
ggsave("../plots/synth_data.png", width=8, height=4)
```

Define a function to perform the model fit, then apply it to each scenario

```{r}
# Define function that takes simulated data
my_sampling = function(method, ts, cases) {
  data = data_init(data_consts, n_times = length(ts), ts = ts, cases = cases)
  sampling(stan_model(method),
           data = data,
           iter = n_iter,
           chains = 1)
}

# Apply function to simulated data
tictoc::tic("Running all scenarios")
hr = 60*60
fits_scenarios = pbmclapply(seq_len(nrow(scenarios_long)), function(i) {
  with_timeout(
    my_sampling(scenarios_long$method[i], scenarios_long$ts[[i]], scenarios_long$cases[[i]]),
    cpu = 3*hr)
})
tictoc::toc()
```

```{r}
# Extract parameters into dataframe
estimates_scenarios = lapply(seq_len(length(fits_scenarios)), function(i) {
  fit = fits_scenarios[[i]]
  if (scenarios_long$method[i] == "../stan/champagne2022_poisson.stan") {
    posterior = rstan::extract(fit, c("lambda")) %>%
      as_tibble() %>%
      mutate(phi_inv = NA, eps = NA, kappa = NA, phase = NA)
  } else {
    posterior = rstan::extract(fit, c("lambda", "phi_inv", "eps", "kappa", "phase")) %>%
      as_tibble()
  }
  return(posterior)
})

# Attach re-estimated parameters
scenarios_long$est_lambda = lapply(estimates_scenarios, function(x) {x$lambda})
scenarios_long$est_phi = lapply(estimates_scenarios, function(x) {1/x$phi_inv})
scenarios_long$phi = 1/scenarios_long$phi_inv
scenarios_long$est_eps = lapply(estimates_scenarios, function(x) {x$eps})
scenarios_long$est_kappa = lapply(estimates_scenarios, function(x) {x$kappa})
scenarios_long$est_phase = lapply(estimates_scenarios, function(x) {x$phase})

# Attach posterior predictions
scenarios_long$est_incidence = lapply(seq_len(nrow(scenarios_long)), function(x) {
  x = fits_scenarios[[i]]
  scenario = scenarios_long[i,]
  method = scenario$method
  data_sim = data_init(data_consts, n_times = length(scenario$ts[[1]]), ts = scenario$ts[[1]], cases = scenario$cases[[1]])
  incidence = rstan::extract(x, "incidence")[[1]]
  if (n_traces < dim(incidence)[1]) {
    sample_ix = seq_len(dim(incidence)[1])
  } else {
    sample_ix = sample(seq_len(dim(incidence)[1]), n_traces, replace=T)
  }
  
  incidence_sample_nonseasonal = as_tibble(t(incidence[sample_ix,])) %>%
    mutate(j = row_number()) %>%
    pivot_longer(-j, names_to = "trace", values_to = "incidence") %>%
    drop_na(j) %>%
    group_by(j) %>%
    mutate(ts = data_sim$ts[j],
           lower = quantile(incidence, 0.025, na.rm=T),
           upper = quantile(incidence, 0.975, na.rm=T),
           legend = "95% prediction interval")
})
```

Diagnostic plots

```{r}
# Interesting parameter estimates
all_plots = list()
for (param in c("lambda", "phi", "eps", "kappa", "phase")) {
  plot_data = scenarios_long %>%
    unnest(!!paste0("est_", param)) %>% 
    mutate(value = get(paste0("est_", param))) %>%
    drop_na(!!param)
  
  true_values = plot_data %>%
    mutate(true_value = get(param)) %>%
    distinct(lambda, eps, true_value)
  
  posterior_ranges = tribble(
    ~parameter, ~min, ~max,
    "lambda", 0, NA,
    "phi", 0, NA,
    "eps", 0, 1,
    "kappa", 0, 10,
    "phase", 0, years,
    "tstar", 0, n_years,
    "xi", 0, 1
  ) %>%
    filter(parameter == param)
  
  param_rename = make_greek(param)
  if (n_repetitions > 1) {
    title = paste("Posterior estimates of", param_rename, "under", n_repetitions, "repetitions")
  } else {
    title = paste("Posterior estimate of", param_rename)
  }
  p = ggplot(plot_data, aes(x = value, fill = method, color = method, group = interaction(method, rep))) +
    geom_vline(data=true_values, aes(xintercept = true_value), linetype="dashed") +
    geom_density(alpha = 0.5) +
    facet_grid(rows = vars(lambda), cols = vars(eps), labeller = plot_labeller, scales="free_y") +
    scale_x_continuous(limits = c(posterior_ranges$min, posterior_ranges$max)) +
    scale_color_brewer(palette = "Set2") +
    scale_fill_brewer(palette = "Set2") +
    labs(title = title,
         x = "Value",
         y = "Posterior density") +
    theme(legend.position = "none")
  all_plots = c(all_plots, p)
  print(p)
}
# do.call(wrap_plots, all_plots)
```

Plot incidence fits

```{r}
# incidence_scenarios = lapply(fits_scenarios, extract_incidence, scenarios_long$ts[[1]])
# incidence_join = lapply(seq_along(incidence_scenarios), function(i) {
#   incidence_scenarios[[i]] %>%
#     mutate(ID = i,
#            lambda = scenarios_long$lambda[i],
#            eps = scenarios_long$eps[i],
#            rep = scenarios_long$rep[i])
# }) %>%
#   bind_rows()

incidence_join = lapply(seq_len(nrow(scenarios_long)), function(i) {
  est_incidence = scenarios_long$est_incidence[[i]] %>%
    mutate(method = scenarios_long$method[i],
           lambda = scenarios_long$lambda[i],
           eps = scenarios_long$eps[i],
           rep = scenarios_long$rep[i])
}) %>%
  bind_rows()

scenarios_overlay = scenarios %>%
  unnest(c(ts, cases))

max_y = max(scenarios_overlay$cases) * 1.2

ggplot(incidence_join, aes(x = ts, y = incidence, color=method, group = factor(method, rep))) +
  geom_line(alpha = 0.25) +
  geom_point(data=scenarios_overlay, aes(y=cases)) +
  # geom_vline(data=true_values, aes(xintercept = true_value), linetype="dashed") +
  # geom_density(alpha = 0.5) +
  facet_grid(rows = vars(lambda), cols = vars(eps), labeller = plot_labeller) +
  # scale_fill_manual(values = param_colors, drop=F) +
  # scale_color_manual(values = param_colors, drop=F) +
  coord_cartesian(ylim = c(NA, max_y)) +
  labs(title = "Estimated incidence") +
  scale_y_log10(labels = label_auto2) +
  scale_color_brewer(palette = "Set2") +
  theme(legend.position = "none")

ggsave("../plots/synth_modelled_incidence.png", width=8, height=4)
```