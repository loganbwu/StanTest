_---
title: "PLAN for Chapter 1. Methodology for fitting ODE epidemic models"
subtitle: "This RMarkdown is a template as initially outlined in the progress report. Each task will be outlined and then followed by a code block to be completed."
output:
html_notebook:
number_sections: true
---


This document is for fitting an epidemic model where the system begins out of equilibrium and gradually returns to equilibrium.

Method:

1. Lambda takes the form of a step function: lambda(t) = *λ* for t<0, = *λ + Δλ* for t >= 0
2. We find an approximate solution for *λ* and *X* for t=0 by assuming equilibrium for t<0 at data point Incidence(t=0)
3. We calibrate *Δλ* and/or other parameters by fitting to data for t>=0

```{r setup}
library(R.utils)
library(tidyverse)
library(rstan)
library(rstansim) # devtools::install_github("ewan-keith/rstansim")
library(parallel)
library(patchwork)
library(pbmcapply)
library(pbapply)
library(memoise)
library(RColorBrewer)
source("../R/constants.R")
source("../R/load_functions.R")

n_cores = parallelly::availableCores()
options(mc.cores = n_cores)
message("Running on ", n_cores, " cores")
rstan_options(auto_write = TRUE)

n_years = 5
n_iter = 50 # should be at least 500
n_chains = 2
n_repetitions = 1 # how many times to duplicate each scenario
cores_per_sampler = n_chains # 1 for mclapply, or n_chains if not running lots of scenarios
limit_runs = Inf # set to a finite number for testing, or Inf to run all
timelimit_per_run = 60*60 * 5
n_traces = 200 # limit for plotting sample trajectories

param_colors = brewer.pal(4, "Set2")
names(param_colors) = c("lambda", "phi", "eps", "kappa")
```

## Model implementation

Generate some data

```{r}
#initial conditions
I_init = 0.01
y0 = c(Il=0, I0=I_init, Sl=0, S0=1-I_init, CumulativeInfections=0)

# constants for Stan
data_consts = list(y0 = y0,
                   t0 = -100*years,
                   N = 100000, # population size
                   r = 1./60, # r
                   gammal = 1./223, # gammal
                   f = 1./72, # f
                   alpha = 0.21, # alpha
                   beta = 0.66, # beta
                   rho = 0.21, # rho
                   delta = 0,
                   phase = years/2
)

n_times = annual_subdivisions * n_years
data = data_init(data_consts,
                 ts = seq_len(n_times)*years/annual_subdivisions,
                 cases = rep(1, n_data),
                 n_times = n_times)
params = list(lambda=0.01, phi_inv=0.1, eps=0.01, kappa=1, xi=0.9, tstar=365*5)

sim = my_simulate_data(
  file = "../stan/champagne2022_nonstationary_2.stan",
  path = "sim_data",
  data_name = "nonstationary",
  input_data = data,
  param_values = params,
  vars = c("ts", "incidence", "sim_cases")
)

ggplot(sim, aes(x=ts/years, y=incidence)) +
  geom_line() +
  geom_point(aes(y = cases)) +
  scale_x_continuous(breaks = 0:100)
```

Insert the new seasonal data into a data list and run the seasonal model (MLE and posterior sampling) on it.

```{r,}
# Fit data
# Edit data with generated values
data_sim = data_consts
data_sim$n_times = nrow(sim)
data_sim$ts = sim$ts
data_sim$cases = sim$cases
```

```{r}
fit = sampling(stan_model("../stan/champagne2022_nonstationary.stan"),
               data = data_sim,
               iter = n_iter,
               init = list(rep(params, n_chains)),
               chains = n_chains,
               seed = 0)

# pairs(fit_seasonal, pars=c("lambda", "phi_inv"))

smr_pred_seasonal <- with(sim, cbind(as.data.frame(
  summary(
    fit,
    pars = "incidence",
    probs = c(0.05, 0.5, 0.95)
  )$summary),
  t=t[1:(nrow(sim)-1)], cases=cases[1:(nrow(sim)-1)])) %>%
  setNames(colnames({.}))

ggplot(smr_pred_seasonal, mapping = aes(x = t)) +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), fill = c_posterior, alpha = 0.35) +
  geom_line(mapping = aes(y = `50%`), color = c_posterior) + 
  geom_point(mapping = aes(y = cases)) +
  labs(x = "Day", y = "Cases") +
  coord_cartesian(ylim = c(0, NA))
```

```{r}
posteriors = rstan::extract(fit, c("lambda", "phi_inv")) %>%
  as_tibble()

# Plot posterior densities
posterior_nonseasonal %>%
  mutate(phi = 1/phi_inv,
         phi_inv = NULL) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  ggplot(aes(x = value, fill=parameter, color=parameter)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values = param_colors, drop=F) +
  scale_color_manual(values = param_colors, drop=F) +
  # coord_cartesian(xlim = c(0, NA)) +
  facet_wrap(vars(parameter), scales="free") +
  labs(subtitle = "Non-seasonal model")
```

Can we perform this with the t-cutoff as a parameter?

```{r}
fit_tstar = sampling(stan_model("../stan/champagne2022_nonstationary_2.stan"),
                     data = data_sim,
                     iter = n_iter,
                     chains = n_chains,
                     seed = 0)
```

```{r}
posterior = rstan::extract(fit_tstar, c("lambda", "phi_inv", "tstar", "xi")) %>%
  as_tibble()

# Plot posterior densities
posterior %>%
  mutate(phi = 1/phi_inv,
         phi_inv = NULL) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  ggplot(aes(x = value, fill=parameter, color=parameter)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values = param_colors, drop=F) +
  scale_color_manual(values = param_colors, drop=F) +
  # coord_cartesian(xlim = c(0, NA)) +
  facet_wrap(vars(parameter), scales="free") +
  labs(subtitle = "Non-seasonal model")

n_traces = 100
incidence = rstan::extract(fit_tstar, "incidence")[[1]]
sample_ix = sample(seq_len(dim(incidence)[1]), n_traces, replace=T)
incidence_sample_nonseasonal = as_tibble(t(incidence[sample_ix,])) %>%
  mutate(j = row_number()) %>%
  pivot_longer(-j, names_to = "trace", values_to = "incidence") %>%
  drop_na(j) %>%
  group_by(j) %>%
  mutate(ts = data_sim$ts[j],
         lower = quantile(incidence, 0.025, na.rm=T),
         upper = quantile(incidence, 0.975, na.rm=T),
         legend = "95% prediction interval")

ggplot(mapping = aes(x=ts)) +
  geom_ribbon(data = incidence_sample_nonseasonal,
              aes(ymin=lower, ymax=upper, fill="95% mean incidence interval"),
              alpha = 0.5) +
  geom_point(data = tibble(ts = data_sim$ts, cases = data_sim$cases),
             aes(y = cases, group = NULL, color="Incidence data")) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_fill_manual("", 
                    breaks = c("95% case prediction interval", "95% mean incidence interval", "Incidence data"),
                    values = c("steelblue", "tomato", "black")) +
  scale_colour_manual("", 
                      breaks = c("95% case prediction interval", "95% mean incidence interval", "Incidence data"),
                      values = c("steelblue", "tomato", "black")) +
  labs(subtitle = "Seasonal model, monthly synthetic data",
       x = "Day",
       y = "Monthly incidence")
```

Can we make a variety of scenarios
Define a function to simulate cases for a scenario

```{r}
simulate_cases = function(data_consts, tstar, xi) {
  n_data = annual_subdivisions * n_years
  data = data_init(data_consts,
                   cases = rep(1, n_data),
                   ts = seq_len(n_data) * years / annual_subdivisions,
                   n_times = n_data)
  params = list(lambda=0.01, phi_inv=0.1, eps=0.01, kappa=1, xi=xi, tstar=tstar)
  synth_df = suppressMessages(my_simulate_data(
    file = "../stan/champagne2022_nonstationary_2.stan",
    path = "sim_data",
    data_name = "nonstationary",
    input_data = data,
    param_values = params,
    vars = c("ts", "incidence", "sim_cases")
  ))
}
```

Create scenarios

```{r}
# Define the scenarios
n_years = 10
n_reps = 1
range_tstar = c(0.25, 0.5, 0.75) * n_years * years
range_xi = c(0, 0.25, 0.5, 0.75, 1)
scenarios = expand_grid(
  tstar = range_tstar,
  xi = range_xi,
  rep = seq_len(n_reps)
) %>%
  mutate(ID = LETTERS[row_number()], .before=0)

# Simulate cases for each scenario
cases_scenarios = lapply(seq_len(nrow(scenarios)), function(i) {
  tstar = scenarios$tstar[i]
  xi = scenarios$xi[i]
  simulate_cases(data_consts, tstar, xi)
})

# Attach simulation results to the scenarios dataframe
scenarios$ts = lapply(cases_scenarios, function(x) {x$ts})
scenarios$cases = lapply(cases_scenarios, function(x) {x$cases})
```

Define a function to perform the model fit, then apply it to each scenario

```{r}
# Define function that takes simulated data
my_sampling = function(data_consts, ts, cases) {
  n_data = length(ts)
  data = data_init(data_consts,
                   cases = cases,
                   ts = ts,
                   n_times = n_data)
  fit = sampling(stan_model("../stan/champagne2022_nonstationary_2.stan"),
                 data = data,
                 iter = n_iter,
                 chains = 1,
                 seed = 0)
}

# Apply function to simulated data
fits_scenarios = lapply(seq_len(nrow(scenarios)), function(i) {
  my_sampling(data_consts, scenarios$ts[[i]], scenarios$cases[[i]])
})

# Extract parameters into dataframe
estimates_scenarios = lapply(fits_scenarios, function(x) {
  posterior = rstan::extract(x, c("lambda", "phi_inv", "tstar", "xi")) %>%
    as_tibble()
})

# Attach re-estimated parameters
scenarios$est_lambda = lapply(estimates_scenarios, function(x) {x$lambda})
scenarios$est_phi_inv = lapply(estimates_scenarios, function(x) {x$phi_inv})
scenarios$est_tstar = lapply(estimates_scenarios, function(x) {x$tstar})
scenarios$est_xi = lapply(estimates_scenarios, function(x) {x$xi})

# Attach posterior predictions
```


Get the Rondonia data

```{r}
path = "/Users/wu.l/Documents/MalariaData/data-raw/brazil/integrated_dataset_Baroni2020.RData"
load(path)
rondonia.all = integrated_dataset %>%
  filter(exam.result == "vivax",
         infection.state == "RO") %>%
  mutate(notification.date = as.Date(paste(notification.year, notification.month, "01", sep="-")) + months(1) - days(1)) %>%
  count(notification.year, notification.date, name = "cases") %>%
  mutate(include = ifelse(notification.year >= 2009 & notification.year <= 2018, "grey20", "grey")) %>%
  as_tibble()

ggplot(rondonia.all, aes(x = notification.date, y=cases, fill=include)) +
  geom_col() +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_date(date_breaks = "years", date_labels = "%Y") +
  scale_fill_identity() +
  labs(title = "Selected monthly P. vivax cases infected in Rondonia",
       x = "Notification date",
       y = "Cases")

ggsave("plots/rondonia_selected.png", width=8, height=4)

rondonia = rondonia.all %>%
  filter(include == "grey20")
```

Set up data and run

```{r}
data_nonst = data_init(data_consts,
                       t0 = -100*years,
                       n_times = nrow(rondonia),
                       ts = seq_len(nrow(rondonia)) * years / annual_subdivisions,
                       cases = rondonia$cases,
                       eps = 0.5,
                       kappa = 5,
                       tstar = years*2)
tictoc::tic()
fit_rond = sampling(stan_model("../stan/champagne2022_nonstationary_2.stan"),
                    data = data_nonst,
                    iter = n_iter,
                    chains = n_chains,
                    cores = n_chains)
tictoc::toc()
```

```{r}
posteriors = rstan::extract(fit_rond, c("lambda", "phi_inv", "tstar", "xi")) %>%
  as_tibble()

# Plot posterior densities
posteriors %>%
  mutate(phi = 1/phi_inv,
         phi_inv = NULL) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  ggplot(aes(x = value, fill=parameter, color=parameter)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values = param_colors, drop=F) +
  scale_color_manual(values = param_colors, drop=F) +
  # coord_cartesian(xlim = c(0, NA)) +
  facet_wrap(vars(parameter), scales="free") +
  labs(subtitle = "Non-seasonal model")
```
