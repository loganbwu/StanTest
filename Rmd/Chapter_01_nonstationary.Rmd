_---
title: "PLAN for Chapter 1. Methodology for fitting ODE epidemic models"
subtitle: "This RMarkdown is a template as initially outlined in the progress report. Each task will be outlined and then followed by a code block to be completed."
output:
html_notebook:
number_sections: true
---


This document is for fitting an epidemic model where the system begins out of equilibrium and gradually returns to equilibrium.

Method:

1. Lambda takes the form of a step function: lambda(t) = *λ* for t<0, = *λ + Δλ* for t >= 0
2. We find an approximate solution for *λ* and *X* for t=0 by assuming equilibrium for t<0 at data point Incidence(t=0)
3. We calibrate *Δλ* and/or other parameters by fitting to data for t>=0

```{r setup}
library(R.utils)
library(tidyverse)
library(rstan)
library(rstansim) # devtools::install_github("ewan-keith/rstansim")
library(parallel)
library(patchwork)
library(pbmcapply)
library(pbapply)
library(memoise)
library(RColorBrewer)
source("../R/constants.R")
source("../R/load_functions.R")

n_cores = parallelly::availableCores()
options(mc.cores = n_cores)
message("Running on ", n_cores, " cores")
rstan_options(auto_write = TRUE)

n_iter = 100 # should be at least 500
n_chains = 4
n_repetitions = 3 # how many times to duplicate each scenario
limit_runs = Inf # set to a finite number for testing, or Inf to run all
timelimit_per_run = 60*60 * 5
n_traces = 200 # limit for plotting sample trajectories
```

## Model implementation

Generate some data

```{r}
#initial conditions
I_init = 0.05
y0 = c(Il=0, I0=I_init, Sl=0, S0=1-I_init, CumulativeInfections=0)
n_years = 10
tstar_for_testing = 5*years

# constants for Stan
data_consts = list(y0 = y0,
                   t0 = -50*years,
                   N = 100000, # population size
                   r = 1./60, # r
                   gammal = 1./223, # gammal
                   f = 1./72, # f
                   alpha = 0.21, # alpha
                   beta = 0.66, # beta
                   rho = 0.21, # rho
                   delta = 0,
                   phase = years/2
)
```

Simulate some dummy data

```{r}
n_times = annual_subdivisions * n_years
data = data_init(data_consts,
                 ts = seq_len(n_times)*years/annual_subdivisions,
                 cases = rep(1, n_times),
                 n_times = n_times)
params = list(lambda=0.01, phi_inv=0.1, eps=0.01, kappa=1, phase=130, xi=0.9, tstar=tstar_for_testing)

sim = my_simulate_data(
  file = "../stan/champagne2022_nonstationary_2.stan",
  path = "sim_data",
  data_name = "nonstationary",
  input_data = data,
  param_values = params,
  vars = c("ts", "incidence", "sim_cases")
)

ggplot(sim, aes(x=ts/years, y=incidence)) +
  geom_line() +
  geom_point(aes(y = cases)) +
  scale_x_continuous(breaks = 0:100)
```

Insert the new seasonal data into a data list and run the seasonal model (MLE and posterior sampling) on it.

```{r,}
# Fit data
# Edit data with generated values
data_sim = data_init(data_consts,
                     n_times = nrow(sim),
                     ts = sim$ts,
                     cases = sim$cases,
                     tstar = tstar_for_testing)
```

Can we perform this with the t-cutoff as a parameter?

```{r}
fit_tstar = sampling(stan_model("../stan/champagne2022_nonstationary_2.stan"),
                     data = data_sim,
                     iter = n_iter,
                     chains = n_chains,
                     seed = 0)
```

```{r}
posterior = rstan::extract(fit_tstar, c("lambda", "phi_inv", "eps", "kappa", "phase", "tstar", "xi")) %>%
  as_tibble()

# Plot posterior densities
posterior %>%
  mutate(phi = 1/phi_inv,
         phi_inv = NULL) %>%
  pivot_longer(everything(), names_to = "parameter", values_to = "value") %>%
  ggplot(aes(x = value, fill=parameter, color=parameter)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values = param_colors, drop=F) +
  scale_color_manual(values = param_colors, drop=F) +
  # coord_cartesian(xlim = c(0, NA)) +
  facet_wrap(vars(parameter), scales="free") +
  labs(subtitle = "Non-seasonal model")

n_traces = 100
incidence = rstan::extract(fit_tstar, "incidence")[[1]]
sample_ix = sample(seq_len(dim(incidence)[1]), n_traces, replace=T)
incidence_sample_nonseasonal = as_tibble(t(incidence[sample_ix,])) %>%
  mutate(j = row_number()) %>%
  pivot_longer(-j, names_to = "trace", values_to = "incidence") %>%
  drop_na(j) %>%
  group_by(j) %>%
  mutate(ts = data_sim$ts[j],
         lower = quantile(incidence, 0.025, na.rm=T),
         upper = quantile(incidence, 0.975, na.rm=T),
         legend = "95% prediction interval")

ggplot(mapping = aes(x=ts)) +
  geom_ribbon(data = incidence_sample_nonseasonal,
              aes(ymin=lower, ymax=upper, fill="95% mean incidence interval"),
              alpha = 0.5) +
  geom_point(data = tibble(ts = data_sim$ts, cases = data_sim$cases),
             aes(y = cases, group = NULL, color="Incidence data")) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_fill_manual("", 
                    breaks = c("95% case prediction interval", "95% mean incidence interval", "Incidence data"),
                    values = c("steelblue", "tomato", "black")) +
  scale_colour_manual("", 
                      breaks = c("95% case prediction interval", "95% mean incidence interval", "Incidence data"),
                      values = c("steelblue", "tomato", "black")) +
  labs(subtitle = "Seasonal model, monthly synthetic data",
       x = "Day",
       y = "Monthly incidence")
```

# Can we make a variety of scenarios?
Define a function to simulate cases for a scenario

```{r}
simulate_cases = function(data_consts, lambda, tstar, xi) {
  n_times = annual_subdivisions * n_years
  data = data_init(data_consts,
                   cases = rep(1, n_times),
                   ts = seq_len(n_times) * years / annual_subdivisions,
                   n_times = n_times)
  params = list(lambda=lambda, phi_inv=0.1, eps=0.01, phase = 130, kappa=1, xi=xi, tstar=tstar)
  synth_df = my_simulate_data(
    file = "../stan/champagne2022_nonstationary_2.stan",
    path = "sim_data",
    data_name = "nonstationary",
    input_data = data,
    param_values = params,
    vars = c("ts", "incidence", "sim_cases")
  )
}
```

Create scenarios

```{r}
# Define the scenarios
range_tstar = c(0.25, 0.5, 0.75) * n_years * years
range_xi = c(0.25, 0.5, 0.75)
scenarios = expand_grid(
  lambda = 0.01,
  tstar = range_tstar,
  xi = range_xi,
  rep = seq_len(n_repetitions)
) %>%
  mutate(ID = LETTERS[row_number()], .before=0)

# Simulate cases for each scenario
cases_scenarios = pbmclapply(seq_len(nrow(scenarios)), function(i) {
  lambda = scenarios$lambda[i]
  tstar = scenarios$tstar[i]
  xi = scenarios$xi[i]
  simulate_cases(data_consts, lambda, tstar, xi)
})

# Attach simulation results to the scenarios dataframe
scenarios$ts = lapply(cases_scenarios, function(x) {x$ts})
scenarios$cases = lapply(cases_scenarios, function(x) {x$cases})
```

What do our synthetic data look like?

```{r}
scenarios %>%
  # distinct(scenario_ID, .keep_all=T) %>%
  unnest(cols = c("ts", "cases")) %>%
  ggplot(aes(x = ts/years, y = cases, group=interaction(tstar, xi, rep))) +
  geom_line(alpha = 0.6) +
  scale_color_gradient(trans = "log", breaks=10^seq(-5, 5)) +
  scale_y_log10(labels = label_auto2) +
  facet_grid(rows = vars(tstar),
             cols = vars(xi),
             labeller = plot_labeller) +
  labs(x = "Year",
       y = "Monthly cases")
```

Define a function to perform the model fit, then apply it to each scenario

```{r}
# Define function that takes simulated data
my_sampling = function(data_consts, ts, cases) {
  n_times = length(ts)
  data = data_init(data_consts,
                   cases = cases,
                   ts = ts,
                   n_times = n_times)
  fit = sampling(stan_model("../stan/champagne2022_nonstationary_2.stan"),
                 data = data,
                 iter = n_iter,
                 chains = 1,
                 seed = 0)
}

# Apply function to simulated data
fits_scenarios = pbmclapply(seq_len(nrow(scenarios)), function(i) {
  my_sampling(data_consts, scenarios$ts[[i]], scenarios$cases[[i]])
})

# Extract parameters into dataframe
estimates_scenarios = lapply(fits_scenarios, function(x) {
  posterior = rstan::extract(x, c("lambda", "phi_inv", "tstar", "xi")) %>%
    as_tibble()
})

# Attach re-estimated parameters
scenarios$est_lambda = lapply(estimates_scenarios, function(x) {x$lambda})
scenarios$est_phi_inv = lapply(estimates_scenarios, function(x) {x$phi_inv})
scenarios$est_tstar = lapply(estimates_scenarios, function(x) {x$tstar})
scenarios$est_xi = lapply(estimates_scenarios, function(x) {x$xi})

# Attach posterior predictions

```

Do diagnostic plots

```{r}
# parameter estimates
for (param in c("lambda", "tstar", "xi")) {
  plot_data = scenarios %>%
    unnest(!!paste0("est_", param)) %>% 
    mutate(value = get(paste0("est_", param)))
  true_values = plot_data %>%
    mutate(true_value = get(param)) %>%
    distinct(tstar, xi, true_value)
  p = ggplot(plot_data, aes(x = value, fill = param, color = param, group = rep)) +
    geom_vline(data=true_values, aes(xintercept = true_value), linetype="dashed") +
    geom_density(alpha = 0.5) +
    facet_grid(rows = vars(tstar), cols = vars(xi), labeller = plot_labeller, scales="free_y") +
    scale_fill_manual(values = param_colors, drop=F) +
    scale_color_manual(values = param_colors, drop=F) +
    labs(title = paste("Variable:", param))
  print(p)
}

```
